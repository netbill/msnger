// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanFailedOutboxEvents = `-- name: CleanFailedOutboxEvents :exec
UPDATE outbox_events
SET
    status = 'pending',
    attempts = 0,
    next_attempt_at = (now() AT TIME ZONE 'UTC')
WHERE status = 'failed'
`

func (q *Queries) CleanFailedOutboxEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanFailedOutboxEvents)
	return err
}

const cleanProcessingOutboxEvents = `-- name: CleanProcessingOutboxEvents :exec
UPDATE outbox_events
SET
    status = 'pending',
    reserved_by = NULL,
    next_attempt_at = (now() AT TIME ZONE 'UTC')
WHERE status = 'processing'
`

func (q *Queries) CleanProcessingOutboxEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanProcessingOutboxEvents)
	return err
}

const cleanReservedProcessingOutboxEvents = `-- name: CleanReservedProcessingOutboxEvents :exec
UPDATE outbox_events
SET
    status = 'pending',
    reserved_by = NULL,
    next_attempt_at = (now() AT TIME ZONE 'UTC')
WHERE status = 'processing'
  AND reserved_by = ANY($1::text[])
`

func (q *Queries) CleanReservedProcessingOutboxEvents(ctx context.Context, workerIds []string) error {
	_, err := q.db.Exec(ctx, cleanReservedProcessingOutboxEvents, workerIds)
	return err
}

const getOutboxEventByID = `-- name: GetOutboxEventByID :one
SELECT event_id, seq, topic, key, type, version, producer, payload, reserved_by, status, attempts, next_attempt_at, last_attempt_at, last_error, sent_at, created_at
FROM outbox_events
WHERE event_id = $1
`

func (q *Queries) GetOutboxEventByID(ctx context.Context, eventID pgtype.UUID) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, getOutboxEventByID, eventID)
	var i OutboxEvent
	err := row.Scan(
		&i.EventID,
		&i.Seq,
		&i.Topic,
		&i.Key,
		&i.Type,
		&i.Version,
		&i.Producer,
		&i.Payload,
		&i.ReservedBy,
		&i.Status,
		&i.Attempts,
		&i.NextAttemptAt,
		&i.LastAttemptAt,
		&i.LastError,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const insertOutboxEvent = `-- name: InsertOutboxEvent :one
INSERT INTO outbox_events (
    event_id, topic, key, type, version, producer, payload,
    status, attempts, next_attempt_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7::jsonb,
    $8,
    $9,
    $10
)
ON CONFLICT (event_id) DO NOTHING
RETURNING event_id, seq, topic, key, type, version, producer, payload, reserved_by, status, attempts, next_attempt_at, last_attempt_at, last_error, sent_at, created_at
`

type InsertOutboxEventParams struct {
	EventID       pgtype.UUID
	Topic         string
	Key           string
	Type          string
	Version       int32
	Producer      string
	Payload       []byte
	Status        OutboxEventStatus
	Attempts      int32
	NextAttemptAt pgtype.Timestamptz
}

func (q *Queries) InsertOutboxEvent(ctx context.Context, arg InsertOutboxEventParams) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, insertOutboxEvent,
		arg.EventID,
		arg.Topic,
		arg.Key,
		arg.Type,
		arg.Version,
		arg.Producer,
		arg.Payload,
		arg.Status,
		arg.Attempts,
		arg.NextAttemptAt,
	)
	var i OutboxEvent
	err := row.Scan(
		&i.EventID,
		&i.Seq,
		&i.Topic,
		&i.Key,
		&i.Type,
		&i.Version,
		&i.Producer,
		&i.Payload,
		&i.ReservedBy,
		&i.Status,
		&i.Attempts,
		&i.NextAttemptAt,
		&i.LastAttemptAt,
		&i.LastError,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const markOutboxEventsAsFailed = `-- name: MarkOutboxEventsAsFailed :exec
WITH inp AS (
    SELECT i.event_id, r.last_error
    FROM unnest($2::uuid[]) WITH ORDINALITY AS i(event_id, ord)
    JOIN unnest($3::text[]) WITH ORDINALITY AS r(last_error, ord)
        USING (ord)
)
UPDATE outbox_events e
SET status          = 'failed',
    attempts        = e.attempts + 1,
    last_attempt_at = (now() AT TIME ZONE 'UTC'),
    last_error      = inp.last_error,
    reserved_by     = NULL
    FROM inp
WHERE e.event_id = inp.event_id
    AND e.status = 'processing'
    AND e.reserved_by = $1
`

type MarkOutboxEventsAsFailedParams struct {
	WorkerID   pgtype.Text
	EventIds   []pgtype.UUID
	LastErrors []string
}

func (q *Queries) MarkOutboxEventsAsFailed(ctx context.Context, arg MarkOutboxEventsAsFailedParams) error {
	_, err := q.db.Exec(ctx, markOutboxEventsAsFailed, arg.WorkerID, arg.EventIds, arg.LastErrors)
	return err
}

const markOutboxEventsAsPending = `-- name: MarkOutboxEventsAsPending :exec
WITH inp AS (
    SELECT i.event_id, a.last_attempt_at, n.next_attempt_at, r.last_error
    FROM unnest($2::uuid[]) WITH ORDINALITY AS i(event_id, ord)
    JOIN unnest($3::timestamptz[]) WITH ORDINALITY AS a(last_attempt_at, ord)
        USING (ord)
    JOIN unnest($4::timestamptz[]) WITH ORDINALITY AS n(next_attempt_at, ord)
        USING (ord)
    JOIN unnest($5::text[]) WITH ORDINALITY AS r(last_error, ord)
        USING (ord)
)
UPDATE outbox_events e
SET status          = 'pending',
    attempts        = e.attempts + 1,
    last_attempt_at = inp.last_attempt_at,
    next_attempt_at = inp.next_attempt_at,
    last_error      = inp.last_error,
    reserved_by     = NULL
FROM inp
WHERE e.event_id = inp.event_id
    AND e.status = 'processing'
    AND e.reserved_by = $1
`

type MarkOutboxEventsAsPendingParams struct {
	WorkerID       pgtype.Text
	EventIds       []pgtype.UUID
	LastAttemptAts []pgtype.Timestamptz
	NextAttemptAts []pgtype.Timestamptz
	LastErrors     []string
}

func (q *Queries) MarkOutboxEventsAsPending(ctx context.Context, arg MarkOutboxEventsAsPendingParams) error {
	_, err := q.db.Exec(ctx, markOutboxEventsAsPending,
		arg.WorkerID,
		arg.EventIds,
		arg.LastAttemptAts,
		arg.NextAttemptAts,
		arg.LastErrors,
	)
	return err
}

const markOutboxEventsAsSent = `-- name: MarkOutboxEventsAsSent :exec
WITH inp AS (
    SELECT i.event_id, s.sent_at
    FROM unnest($2::uuid[]) WITH ORDINALITY AS i(event_id, ord)
    JOIN unnest($3::timestamptz[]) WITH ORDINALITY AS s(sent_at, ord)
        USING (ord)
)
UPDATE outbox_events e
SET status          = 'sent',
    attempts        = e.attempts + 1,
    sent_at         = inp.sent_at,
    last_attempt_at = inp.sent_at,
    reserved_by     = NULL
    FROM inp
WHERE e.event_id = inp.event_id
    AND e.status = 'processing'
    AND e.reserved_by = $1
`

type MarkOutboxEventsAsSentParams struct {
	WorkerID pgtype.Text
	EventIds []pgtype.UUID
	SentAts  []pgtype.Timestamptz
}

func (q *Queries) MarkOutboxEventsAsSent(ctx context.Context, arg MarkOutboxEventsAsSentParams) error {
	_, err := q.db.Exec(ctx, markOutboxEventsAsSent, arg.WorkerID, arg.EventIds, arg.SentAts)
	return err
}

const reserveOutboxEvents = `-- name: ReserveOutboxEvents :many
WITH ready AS (
    SELECT event_id, seq, topic, key, type, version, producer, payload, reserved_by, status, attempts, next_attempt_at, last_attempt_at, last_error, sent_at, created_at
    FROM outbox_events
    WHERE status = 'pending'
      AND reserved_by IS NULL
      AND next_attempt_at <= (now() AT TIME ZONE 'UTC')
    ORDER BY seq
    FOR UPDATE SKIP LOCKED
    LIMIT $2
),
key_heads AS (
    SELECT DISTINCT ON (r.topic, r.key)
        r.topic,
        r.key,
        r.seq AS head_seq
    FROM ready r
    WHERE NOT EXISTS (
        SELECT 1
        FROM outbox_events p
        WHERE p.topic = r.topic
            AND p.key = r.key
            AND p.status = 'processing'
            AND p.reserved_by IS NOT NULL
    )
    ORDER BY r.topic, r.key, r.seq
),
picked AS (
    SELECT e.event_id
    FROM outbox_events e
    JOIN key_heads k ON k.topic = e.topic AND k.key = e.key
    WHERE e.status = 'pending'
        AND e.reserved_by IS NULL
        AND e.next_attempt_at <= (now() AT TIME ZONE 'UTC')
    ORDER BY k.head_seq, e.seq
    FOR UPDATE SKIP LOCKED
    LIMIT $3
)
UPDATE outbox_events e
SET reserved_by = $1,
    status      = 'processing'
WHERE e.event_id IN (SELECT event_id FROM picked)
RETURNING event_id, seq, topic, key, type, version, producer, payload, reserved_by, status, attempts, next_attempt_at, last_attempt_at, last_error, sent_at, created_at
`

type ReserveOutboxEventsParams struct {
	WorkerID   pgtype.Text
	SortLimit  int32
	BatchLimit int32
}

func (q *Queries) ReserveOutboxEvents(ctx context.Context, arg ReserveOutboxEventsParams) ([]OutboxEvent, error) {
	rows, err := q.db.Query(ctx, reserveOutboxEvents, arg.WorkerID, arg.SortLimit, arg.BatchLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutboxEvent
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.EventID,
			&i.Seq,
			&i.Topic,
			&i.Key,
			&i.Type,
			&i.Version,
			&i.Producer,
			&i.Payload,
			&i.ReservedBy,
			&i.Status,
			&i.Attempts,
			&i.NextAttemptAt,
			&i.LastAttemptAt,
			&i.LastError,
			&i.SentAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
